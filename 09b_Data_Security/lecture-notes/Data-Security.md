# Data Security Lecture

## SQL injection

SQL injection occurs when un-trusted data such as user data from application web pages are added to database queries, materially changing the structure and producing behaviors inconsistent with application design or purpose.

Clever attackers exploit SQL injection vulnerabilities to steal sensitive information, bypass authentication or gain elevated privileges, add or delete rows in the database, deny services, and in extreme cases, gain direct operating system shell access, using the database as a launch point for sophisticated attacks against internal systems.

SQL injection is by far the most dangerous vulnerability impacting online applications today. When you read that hackers have stolen 450,000 user accounts or that 130 million credit card numbers have been exposed, it is very likely that the application was attacked using SQL injection.

### Preventing SQL injection

1.  **Parameterized Queries** - The single most effective thing you can do to prevent SQL injection is to use parameterized queries. If this is done consistently, SQL injection won't be possible.

2.  **Input Validation** - Limiting the data that can be input by a user can certainly be helpful in preventing SQL Injection, but is by no means an effective prevention by itself.

3.  **Limit Database User Privileges** - A web application should always use a database user to connect to the database that has as few permissions as necessary. For example, if your application never deletes data from a particular table, then the database user should not have permission to delete from that table. This helps to limit the damage in the case that there is a SQL Injection vulnerability.

## Hashing

Over the past few years there have been many stories of data breaches divulging sensitive information about 100's of thousands of people.

Many times, these breaches involve sensitive data that has not been stored in a safe manner, meaning if the attacker gets to the data they can easily understand it.

There are many cases in which we need to be able to store data such that it is not readable by unauthorized parties:

- Passwords
- PIN
- Credit card numbers
- Bank account numbers

Depending on the nature of the data and how it's used, it can be protected using one of two techniques: hashing or encryption.

## Hashing

One type of sensitive data systems need to store is user passwords.

1.  We need to be able to *verify* a password but not *recover* it.
2.  A system administrator with access to credential data should not be able to determine a password.
3.  Any hacker that steals a database or set of credentials should not be able to read the passwords.
4.  Even with super-computing capabilities, no one should be able to access the data within any reasonable amount of time.

Hashing process:

1.  Use a one-way function to obfuscate the plain-text password prior to storage.
2.  Use the password supplied by the user, re-hash it, and compare it to the stored password hash value.
3.  Salt the passwords to make it take longer to calculate all possibilities.

## Encryption

> Encryption is the most effective way to achieve data security. When data is sent between two parties or stored, it is stored in an encrypted non-human readable format that requires the key to properly decrypt and understand.

From the [OWASP Guide to Cryptography](https://www.owasp.org/index.php/Guide_to_Cryptography):

### Securing data at rest

1.  Data at rest can use a form of encryption called **symmetric key encryption**
2.  Requires both parties to use the key to encrypt and decrypt data.
3.  Any party possessing the key can read the data.
4.  Has difficulties securing the symmetric key amongst multiple parties.

> Symmetric cryptography involves the parties sharing a common secret passphrase or key. Data is encrypted and decrypted using the same key.

### Securing data in transit

1.  It may be necessary to allow others to send you secure data without worrying that it be intercepted.
2.  Giving the secure key away would not be a good decision.
3.  Asymmetric algorithms allow us to create a **public key** and a **private key**.
4.  The public key is distributed freely.
5.  The private key is kept secret.

> Asymmetric cryptography uses two keys: one to encrypt the data and the other to decrypt.

#### Examples

Web encryption

1.  Secure Socket Layer (SSL) and Transport Layer Security (TLS) are examples of asymmetric key encryption.
2.  SSL was developed by Netscape in 1994 to secure transactions over the WWW.
3.  TLS and SSL are recognized as protocols to provide secure HTTPS for internet transactions. It supports authentication, encryption, and data integrity.

Digital Certificates

1.  Ownership of a public key is certified by use of a digital certificate allowing parties to rely upon the signature generated by the private key.
2.  A **certificate authority** is a trusted third party that provides the certificate.
3.  The CA prevents the attacker from impersonating a server by indicating that the certificate belongs to a particular domain.

Man-in-the-Middle Attack

1.  Even communication performed over SSL is subject to a MITM attack.
2.  The browser sets an SSL session with the attacker while the attacker sets an SSL session with the web server.
3.  The browser warns the user that the digital certificate isn't valid, but the user often ignores the warning because the threat isn't understood.

## Code

The students have read about hashing, encryption, and SQL Injection attacks from the student book. Here, they'll see hashing in action for its most vital use case: storing passwords in the database.

The application is a command-line application that manages student records.

Start by creating a new database called `user-manager` and running `database/user-manager.sql`. The script creates a `users` table to use with this lecture.

Then, run the `UserManagerCli` application. You should:

1. Add a new user
2. Log in with that user
3. Show the list of users

You can then show the database. The passwords are all scrambled and the users all have salt values. There is no way for anyone with this database to know what the passwords originally were except by trying to calculate every combination.

Then you can step through the `JdbcUserDao` class to show how these values get saved to the database and how the user is still able to log in even though you don't have their password in plain text.

- `createUser()` takes new user info (username, hashed password, salt), and saves it to the database.
- `getUserByUsername()` takes a username and returns the retrieved user.
- `getPasswordAndSaltByUsername()` takes a username, returns the password and salt for the calling code to validate.
- `getUsers()` gets all the users from the database and returns them.

Step through the process in `UserManagerCli.addNewUser()` of taking a password, creating a salt and hashing the password before storing it in the database.

But there is a bad bug in the application. See if the students can find it in the `JdbcUserDao`.

`getPasswordAndSaltByUsername()` is using concatenation to build its SQL query. If an attacker can craft a bad value for the username, it could destroy data.

See if the students can come up with a good attack. This one clears the entire `users` table: `'; delete from users;--`.

Then convert it to a prepared statement and show how that won't cause an error now:

```java
String sqlSearchForUser = "SELECT salt, password FROM users WHERE UPPER(username) = ?;";
SqlRowSet results = jdbcTemplate.queryForRowSet(sqlSearchForUser, userName.toUpperCase());
```
